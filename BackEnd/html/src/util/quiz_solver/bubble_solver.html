<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>src.util.quiz_solver.bubble_solver API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.util.quiz_solver.bubble_solver</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.util.quiz_solver.bubble_solver.filter_bubble_contours"><code class="name flex">
<span>def <span class="ident">filter_bubble_contours</span></span>(<span>cnts: List[cv2.Mat | numpy.ndarray]) ‑> List[cv2.Mat | numpy.ndarray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_bubble_contours(cnts: List[MatLike]) -&gt; List[MatLike]:
    &#34;&#34;&#34;
    Filters the contours to keep only those that correspond to bubbles, based on their size and aspect ratio.

    Args:
        cnts: The list of contours extracted from the image.

    Returns:
        A filtered list of contours that are likely to be bubbles.
    &#34;&#34;&#34;
    question_cnts = []
    for c in cnts:
        # Compute the bounding box and aspect ratio of each contour
        (x, y, w, h) = cv2.boundingRect(c)
        ar = w / float(h)

        # Select contours that are sufficiently wide, tall, and have an aspect ratio near 1
        if w &gt;= 30 and h &gt;= 30 and 0.85 &lt;= ar &lt;= 1.3:
            question_cnts.append(c)

    # Sort contours top to bottom
    question_cnts = contours.sort_contours(question_cnts, method=&#34;top-to-bottom&#34;)[0]

    return question_cnts</code></pre>
</details>
<div class="desc"><p>Filters the contours to keep only those that correspond to bubbles, based on their size and aspect ratio.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cnts</code></strong></dt>
<dd>The list of contours extracted from the image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A filtered list of contours that are likely to be bubbles.</p></div>
</dd>
<dt id="src.util.quiz_solver.bubble_solver.get_bubble_contours"><code class="name flex">
<span>def <span class="ident">get_bubble_contours</span></span>(<span>thresh: cv2.Mat | numpy.ndarray) ‑> cv2.Mat | numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bubble_contours(thresh: MatLike) -&gt; MatLike:
    &#34;&#34;&#34;
    Extracts the bubble contours from the thresholded image. This function will retry if it doesn&#39;t find exactly
    50 bubbles (one for each possible question).

    Args:
        thresh: The thresholded binary image.

    Returns:
        A list of bubble contours.
    &#34;&#34;&#34;
    cnts = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    cnts = imutils.grab_contours(cnts)

    bubble_contours = filter_bubble_contours(cnts)

    # Retry if the number of bubble contours isn&#39;t as expected
    if len(bubble_contours) != 50:
        bubble_contours = retry_bubble_contours(thresh)

    return bubble_contours</code></pre>
</details>
<div class="desc"><p>Extracts the bubble contours from the thresholded image. This function will retry if it doesn't find exactly
50 bubbles (one for each possible question).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>thresh</code></strong></dt>
<dd>The thresholded binary image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of bubble contours.</p></div>
</dd>
<dt id="src.util.quiz_solver.bubble_solver.retry_bubble_contours"><code class="name flex">
<span>def <span class="ident">retry_bubble_contours</span></span>(<span>thresh: cv2.Mat | numpy.ndarray) ‑> cv2.Mat | numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retry_bubble_contours(thresh: MatLike) -&gt; MatLike:
    &#34;&#34;&#34;
    Attempts to refine the bubble contours by preprocessing the thresholded image and applying morphological
    operations to close gaps. If the initial contour extraction fails, this method tries again to improve the detection.

    Args:
        thresh: The thresholded binary image.

    Returns:
        The filtered list of contours that correspond to the bubbles.
    &#34;&#34;&#34;
    # Preprocess the image to improve contour detection
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    processed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)

    # Find contours in the processed image
    cnts = cv2.findContours(processed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    cnts = imutils.grab_contours(cnts)

    return filter_bubble_contours(cnts)</code></pre>
</details>
<div class="desc"><p>Attempts to refine the bubble contours by preprocessing the thresholded image and applying morphological
operations to close gaps. If the initial contour extraction fails, this method tries again to improve the detection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>thresh</code></strong></dt>
<dd>The thresholded binary image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The filtered list of contours that correspond to the bubbles.</p></div>
</dd>
<dt id="src.util.quiz_solver.bubble_solver.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>thresh: cv2.Mat | numpy.ndarray,<br>bubble_contours: List[cv2.Mat | numpy.ndarray],<br>questions: List[List[int]],<br>nz_threshold: int = 1000) ‑> tuple[typing.Dict[int, typing.List[int]], float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(thresh: MatLike, bubble_contours: List[MatLike], questions: List[List[int]], nz_threshold: int = 1000) -&gt; (
        tuple)[Dict[int, List[int]], float]:
    &#34;&#34;&#34;
    Solves the quiz by iterating through the bubbles and comparing with the correct answers.

    Args:
        thresh: The thresholded binary image.
        bubble_contours: The contours of the bubbles.
        questions: The list of correct answers for each question.
        nz_threshold: The minimum number of non-zero pixels required to consider an answer as bubbled.

    Returns:
        A tuple containing the detected answers and the score.
    &#34;&#34;&#34;
    num_correct = 0
    a = {}

    # Loop over the questions and check each set of 5 possible answers
    for (q, i) in enumerate(np.arange(0, len(bubble_contours), 5)):
        if q &gt;= len(questions):
            break
        cnts = contours.sort_contours(bubble_contours[i:i + 5])[0]
        bubbled = None

        for (j, c) in enumerate(cnts):
            mask = np.zeros(thresh.shape, dtype=&#34;uint8&#34;)
            cv2.drawContours(mask, [c], -1, 255, -1)

            mask = cv2.bitwise_and(thresh, thresh, mask=mask)
            total = cv2.countNonZero(mask)

            if total &gt; nz_threshold:
                if bubbled is None:
                    bubbled = [(total, j)]
                else:
                    bubbled.append((total, j))

        if bubbled is None:
            continue

        k = questions[q]
        current_correct = 0

        for ans in k:
            if ans &gt;= len(cnts):
                continue
            if ans in [b[1] for b in bubbled]:
                current_correct += 1

        if current_correct == len(k) and current_correct == len(bubbled):
            num_correct += 1

        for b in bubbled:
            if a.get(q) is None:
                a[q] = [b[1]]
            else:
                a[q].append(b[1])

    sc = (num_correct / len(questions)) * 100
    return a, num_correct</code></pre>
</details>
<div class="desc"><p>Solves the quiz by iterating through the bubbles and comparing with the correct answers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>thresh</code></strong></dt>
<dd>The thresholded binary image.</dd>
<dt><strong><code>bubble_contours</code></strong></dt>
<dd>The contours of the bubbles.</dd>
<dt><strong><code>questions</code></strong></dt>
<dd>The list of correct answers for each question.</dd>
<dt><strong><code>nz_threshold</code></strong></dt>
<dd>The minimum number of non-zero pixels required to consider an answer as bubbled.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple containing the detected answers and the score.</p></div>
</dd>
<dt id="src.util.quiz_solver.bubble_solver.solve_quiz"><code class="name flex">
<span>def <span class="ident">solve_quiz</span></span>(<span>image: cv2.Mat | numpy.ndarray, ans: List[List[int]])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve_quiz(image: MatLike, ans: List[List[int]]):
    &#34;&#34;&#34;
    Solves a quiz by detecting and analyzing the bubbled answers in the image.

    Args:
        image: The input image of the quiz sheet.
        ans: The list of correct answers for each question.

    Returns:
        A tuple with the answers and the score.
    &#34;&#34;&#34;
    image = unsharp_mask(image)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]

    # Detect bubble contours and adjust threshold level
    bubble_contours = [c for c in retry_bubble_contours(thresh)]
    thresh_level = stabilize_threshold_level(bubble_contours, thresh)

    # Solve the quiz by comparing detected bubbles with the correct answers
    return solve(thresh, bubble_contours, ans, nz_threshold=thresh_level)</code></pre>
</details>
<div class="desc"><p>Solves a quiz by detecting and analyzing the bubbled answers in the image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong></dt>
<dd>The input image of the quiz sheet.</dd>
<dt><strong><code>ans</code></strong></dt>
<dd>The list of correct answers for each question.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple with the answers and the score.</p></div>
</dd>
<dt id="src.util.quiz_solver.bubble_solver.stabilize_threshold_level"><code class="name flex">
<span>def <span class="ident">stabilize_threshold_level</span></span>(<span>bubble_contours: List[cv2.Mat | numpy.ndarray],<br>thresh: cv2.Mat | numpy.ndarray) ‑> int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stabilize_threshold_level(bubble_contours: List[MatLike], thresh: MatLike) -&gt; int:
    &#34;&#34;&#34;
    Adjusts the threshold level based on the bubble contours by calculating the number of non-zero pixels in the
    detected bubble regions. This helps refine the detection of the bubbles.

    Args:
        bubble_contours: The contours of the detected bubbles.
        thresh: The thresholded binary image.

    Returns:
        An adjusted threshold value.
    &#34;&#34;&#34;
    bubble_regions = []

    # Loop over the contours and create a mask for each
    for c in bubble_contours:
        (x, y, w, h) = cv2.boundingRect(c)

        # Create a mask for the current bubble contour
        mask = np.zeros(thresh.shape, dtype=&#34;uint8&#34;)
        cv2.drawContours(mask, [c], -1, 255, -1)

        # Apply the mask and count the number of non-zero pixels
        mask = cv2.bitwise_and(thresh, thresh, mask=mask)
        total = cv2.countNonZero(mask)
        bubble_regions.append((total, (x, y, w, h)))

    # Sort bubble regions by the total number of non-zero pixels
    bubble_regions = sorted(bubble_regions, key=lambda ics: ics[0], reverse=True)

    # Return an adjusted threshold based on the highest count
    return int(bubble_regions[0][0] * 0.5) if int(bubble_regions[0][0] * 0.5) &gt; 700 else 700</code></pre>
</details>
<div class="desc"><p>Adjusts the threshold level based on the bubble contours by calculating the number of non-zero pixels in the
detected bubble regions. This helps refine the detection of the bubbles.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bubble_contours</code></strong></dt>
<dd>The contours of the detected bubbles.</dd>
<dt><strong><code>thresh</code></strong></dt>
<dd>The thresholded binary image.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An adjusted threshold value.</p></div>
</dd>
<dt id="src.util.quiz_solver.bubble_solver.unsharp_mask"><code class="name flex">
<span>def <span class="ident">unsharp_mask</span></span>(<span>image: cv2.Mat | numpy.ndarray, ketnel=(5, 5), sigma=1.0, amount=1.0, threshold=0) ‑> cv2.Mat | numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unsharp_mask(image: MatLike, ketnel=(5, 5), sigma=1.0, amount=1.0, threshold=0) -&gt; MatLike:
    &#34;&#34;&#34;
    Applies an unsharp mask to sharpen the image.

    Args:
        image: The input image.
        ketnel: The kernel size for the Gaussian blur.
        sigma: The standard deviation for the Gaussian blur.
        amount: The amount to enhance the sharpness.
        threshold: The threshold to determine where sharpening is applied.

    Returns:
        The sharpened image.
    &#34;&#34;&#34;
    blurred = cv2.GaussianBlur(image, ketnel, sigma)
    sharpened = float(amount + 1) * image - float(amount) * blurred
    sharpened = np.maximum(sharpened, np.zeros(sharpened.shape))
    sharpened = np.minimum(sharpened, 255 * np.ones(sharpened.shape))
    sharpened = sharpened.round().astype(np.uint8)

    if threshold &gt; 0:
        low_contrast_mask = np.abs(image - blurred) &lt; threshold
        np.copyto(sharpened, image, where=low_contrast_mask)

    return sharpened</code></pre>
</details>
<div class="desc"><p>Applies an unsharp mask to sharpen the image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>image</code></strong></dt>
<dd>The input image.</dd>
<dt><strong><code>ketnel</code></strong></dt>
<dd>The kernel size for the Gaussian blur.</dd>
<dt><strong><code>sigma</code></strong></dt>
<dd>The standard deviation for the Gaussian blur.</dd>
<dt><strong><code>amount</code></strong></dt>
<dd>The amount to enhance the sharpness.</dd>
<dt><strong><code>threshold</code></strong></dt>
<dd>The threshold to determine where sharpening is applied.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The sharpened image.</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.util.quiz_solver" href="index.html">src.util.quiz_solver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.util.quiz_solver.bubble_solver.filter_bubble_contours" href="#src.util.quiz_solver.bubble_solver.filter_bubble_contours">filter_bubble_contours</a></code></li>
<li><code><a title="src.util.quiz_solver.bubble_solver.get_bubble_contours" href="#src.util.quiz_solver.bubble_solver.get_bubble_contours">get_bubble_contours</a></code></li>
<li><code><a title="src.util.quiz_solver.bubble_solver.retry_bubble_contours" href="#src.util.quiz_solver.bubble_solver.retry_bubble_contours">retry_bubble_contours</a></code></li>
<li><code><a title="src.util.quiz_solver.bubble_solver.solve" href="#src.util.quiz_solver.bubble_solver.solve">solve</a></code></li>
<li><code><a title="src.util.quiz_solver.bubble_solver.solve_quiz" href="#src.util.quiz_solver.bubble_solver.solve_quiz">solve_quiz</a></code></li>
<li><code><a title="src.util.quiz_solver.bubble_solver.stabilize_threshold_level" href="#src.util.quiz_solver.bubble_solver.stabilize_threshold_level">stabilize_threshold_level</a></code></li>
<li><code><a title="src.util.quiz_solver.bubble_solver.unsharp_mask" href="#src.util.quiz_solver.bubble_solver.unsharp_mask">unsharp_mask</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
